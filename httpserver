#!/usr/bin/python3

import getopt
import socketserver
import socket
import mmap
import sys
import os
import threading
import hashlib
import glob
import re

optlist, _ = getopt.getopt(sys.argv[1:], 'p:o:')
for opt in optlist:
    if opt[0] == '-p':
        port = int(opt[1])
    elif opt[0] == '-o':
        origin = opt[1]

cache = {}

files = glob.glob("www/*")
for f in files:
    opened = open(f, "r+b")
    #TODO change from mmap?
    cache[f[4:]] = mmap.mmap(opened.fileno(), 0)

s = socket.socket()
s.connect((origin, 8080))
regex = re.compile('Content-Length: (\d+)')

class HTTPRequest(socketserver.BaseRequestHandler):
    def __init__(self, request, client_address, server):
        super().__init__(request, client_address, server)

    def handle(self):
        self.data = self.request.recv(1024).strip()
        command, path, version = self.data.split('\r\n'.encode())[0].split()
        if command == "GET".encode():
            global cache
            hashpath = hashlib.sha256(path).hexdigest()
            if hashpath in cache:
                response = cache[hashpath]
                self.request.sendall(response.read())
                response.seek(0)
            else:
                global origin
                global s
                global re
                s.send(b"GET " + path + b" HTTP/1.1\r\nHost: " + \
                        origin.encode() + b":8080\r\n\r\n")
                data = []
                #TODO fix?
                buf = s.recv(4096)
                length = -1
                header = "".encode()
                while "\r\n\r\n".encode() not in buf:
                    header += buf
                    self.request.send(buf)
                    buf = s.recv(4096)

                header += buf
                if 'Content-Length: '.encode() in header:
                    length = re.match(buf).group(1) - (len(header) - header.index('\r\n\r\n') - 4)

                if length == -1:
                    self.recvChunk(buf, "".encode())
                else:
                    recvLength(buf, length)

    def recvChunk(self, buf, prev):
        while '\r\n0\r\n\r\n'.encode() not in (prev + buf):
            prev = buf[-5:]
            self.request.send(buf)
            buf = s.recv(4096)

        self.request.send(buf)

    def recvLength(self, buf, remaining):
        while remaning > 0:
            self.request.send(buf)
            buf = s.recv(4096)
            remaining -= len(buf)

        self.request.send(buf)

class ForkHTTPServer(socketserver.ForkingMixIn, socketserver.TCPServer):
    pass

class HTTPServerFront(object):
    server = 0
    def __init__(self, host, port):
        self.server = ForkHTTPServer((host, port), HTTPRequest)

        server_thread = threading.Thread(target=self.server.serve_forever)
        server_thread.daemon = True
        server_thread.start()
        print("Server started")

        self.server.serve_forever()

        self.server.shutdown()
        self.server.server_close()

if __name__ == "__main__":
    baz = HTTPServerFront("", port)
